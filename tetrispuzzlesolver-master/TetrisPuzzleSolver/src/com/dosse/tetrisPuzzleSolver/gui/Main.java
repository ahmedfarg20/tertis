/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.dosse.tetrisPuzzleSolver.gui;

import com.dosse.tetrisPuzzleSolver.TetrisPuzzleSolver;
import com.dosse.tetrisPuzzleSolver.TetrisPuzzleSolverMT;
import com.dosse.tetrisPuzzleSolver.TetrisPuzzleSolverMT.Solution;
import java.awt.KeyEventDispatcher;
import java.awt.KeyboardFocusManager;
import java.awt.event.KeyEvent;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.zip.GZIPInputStream;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;

/**
 *
 * @author Federico
 */
public class Main extends javax.swing.JFrame {

    private KeyEventDispatcher f9;

    /**
     * Creates new form Main
     */
    public Main() {
        initComponents();
        setMinimumSize(getSize());
        f9 = new KeyEventDispatcher() {
            @Override
            public boolean dispatchKeyEvent(KeyEvent e) {
                if (e.getKeyCode() == KeyEvent.VK_F9 && e.getID() == KeyEvent.KEY_PRESSED) {
                    JFileChooser c = new JFileChooser();
                    c.setDialogTitle("Load state");
                    c.setMultiSelectionEnabled(false);
                    c.showOpenDialog(rootPane);
                    File x = c.getSelectedFile();
                    if (x == null) {
                        return false;
                    }
                    GZIPInputStream fis = null;
                    try {
                        fis = new GZIPInputStream(new FileInputStream(x));
                        setVisible(false);
                        TetrisPuzzleSolverMT solver = TetrisPuzzleSolverMT.loadState(fis);
                        rows.setValue(solver.getHeight());
                        cols.setValue(solver.getWidth());
                        i.setValue(solver.getIBlocks());
                        o.setValue(solver.getOBlocks());
                        t.setValue(solver.getTBlocks());
                        j.setValue(solver.getJBlocks());
                        l.setValue(solver.getLBlocks());
                        s.setValue(solver.getSBlocks());
                        z.setValue(solver.getZBlocks());
                        new Visualizer(solver, Main.this).setVisible(true);
                    } catch (Throwable t) {
                        JOptionPane.showMessageDialog(rootPane, "Invalid saved state", "Error", JOptionPane.ERROR_MESSAGE);
                        setVisible(true);
                    } finally {
                        try {
                            fis.close();
                        } catch (Throwable t) {
                        }
                    }
                }
                return false;
            }
        };
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        rows = new javax.swing.JSpinner();
        cols = new javax.swing.JSpinner();
        jLabel3 = new javax.swing.JLabel();
        i = new javax.swing.JSpinner();
        jLabel4 = new javax.swing.JLabel();
        o = new javax.swing.JSpinner();
        jLabel5 = new javax.swing.JLabel();
        t = new javax.swing.JSpinner();
        jLabel6 = new javax.swing.JLabel();
        j = new javax.swing.JSpinner();
        jLabel7 = new javax.swing.JLabel();
        l = new javax.swing.JSpinner();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        s = new javax.swing.JSpinner();
        z = new javax.swing.JSpinner();
        solve = new javax.swing.JButton();
        jLabel10 = new javax.swing.JLabel();
        optimization = new javax.swing.JComboBox();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Tetris Puzzle Solver");

        jLabel1.setText("Rows");

        jLabel2.setText("Columns");

        rows.setModel(new javax.swing.SpinnerNumberModel(Integer.valueOf(6), Integer.valueOf(0), null, Integer.valueOf(1)));

        cols.setModel(new javax.swing.SpinnerNumberModel(Integer.valueOf(8), Integer.valueOf(1), null, Integer.valueOf(1)));

        jLabel3.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/dosse/tetrisPuzzleSolver/gui/i.png"))); // NOI18N

        i.setModel(new javax.swing.SpinnerNumberModel(Integer.valueOf(1), Integer.valueOf(0), null, Integer.valueOf(1)));

        jLabel4.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/dosse/tetrisPuzzleSolver/gui/o.png"))); // NOI18N

        o.setModel(new javax.swing.SpinnerNumberModel(Integer.valueOf(5), Integer.valueOf(0), null, Integer.valueOf(1)));

        jLabel5.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/dosse/tetrisPuzzleSolver/gui/t.png"))); // NOI18N

        t.setModel(new javax.swing.SpinnerNumberModel(Integer.valueOf(2), Integer.valueOf(0), null, Integer.valueOf(1)));

        jLabel6.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/dosse/tetrisPuzzleSolver/gui/j.png"))); // NOI18N

        j.setModel(new javax.swing.SpinnerNumberModel(Integer.valueOf(0), Integer.valueOf(0), null, Integer.valueOf(1)));

        jLabel7.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/dosse/tetrisPuzzleSolver/gui/l.png"))); // NOI18N

        l.setModel(new javax.swing.SpinnerNumberModel(Integer.valueOf(1), Integer.valueOf(0), null, Integer.valueOf(1)));

        jLabel8.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/dosse/tetrisPuzzleSolver/gui/s.png"))); // NOI18N

        jLabel9.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/dosse/tetrisPuzzleSolver/gui/z.png"))); // NOI18N

        s.setModel(new javax.swing.SpinnerNumberModel(Integer.valueOf(2), Integer.valueOf(0), null, Integer.valueOf(1)));

        z.setModel(new javax.swing.SpinnerNumberModel(Integer.valueOf(1), Integer.valueOf(0), null, Integer.valueOf(1)));

        solve.setText("Solve");
        solve.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                solveActionPerformed(evt);
            }
        });

        jLabel10.setText("Algorithm");

        optimization.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Classic", "Parallel" }));
        optimization.setSelectedIndex(1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(solve, javax.swing.GroupLayout.DEFAULT_SIZE, 185, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel1)
                            .addComponent(jLabel2))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(cols)
                            .addComponent(rows)))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(i))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel4)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(o))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel5)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(t))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel6)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(j))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel7)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(l))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel9)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(z))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel8)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(s))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel10)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(optimization, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(rows, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(cols, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel3)
                    .addComponent(i, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel4)
                    .addComponent(o, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel5)
                    .addComponent(t, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel6)
                    .addComponent(j, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel7)
                    .addComponent(l, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel8)
                    .addComponent(s, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel9)
                    .addComponent(z, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel10)
                    .addComponent(optimization, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(solve)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void solveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_solveActionPerformed
        if (optimization.getSelectedIndex() == 0) {
            new Visualizer(new TetrisPuzzleSolver((Integer) (cols.getValue()), (Integer) (rows.getValue()), (Integer) (i.getValue()), (Integer) (o.getValue()), (Integer) (t.getValue()), (Integer) (j.getValue()), (Integer) (l.getValue()), (Integer) (s.getValue()), (Integer) (z.getValue())), this).setVisible(true);
        } else {
            new Visualizer(new TetrisPuzzleSolverMT((Integer) (cols.getValue()), (Integer) (rows.getValue()), (Integer) (i.getValue()), (Integer) (o.getValue()), (Integer) (t.getValue()), (Integer) (j.getValue()), (Integer) (l.getValue()), (Integer) (s.getValue()), (Integer) (z.getValue())), this).setVisible(true);
        }
        setVisible(false);
    }//GEN-LAST:event_solveActionPerformed

    @Override
    public void setVisible(boolean visible) {
        if(isVisible()==visible) return;
        super.setVisible(visible);
        if (!visible) {
            KeyboardFocusManager.getCurrentKeyboardFocusManager().removeKeyEventDispatcher(f9);
        } else {
            KeyboardFocusManager.getCurrentKeyboardFocusManager().addKeyEventDispatcher(f9);
        }
        System.gc();
    }

    private static void printHelp() {
        System.out.println("Tetris Puzzle Solver - Command Line Help\n"
                + "Syntax: TetrisPuzzleSolver.jar [-nogui | -gui] [-classic | -parallel] -gridRowsxCols -iN -oN -tN -jN -lN -sN -zN\n"
                + "\n"
                + "-nogui: prints output to stdout instead of showing GUI\n"
                + "-gui: shows animated GUI\n"
                + "-classic: use classic algorithm (single thread)\n"
                + "-parallel: use parallel algorithm\n"
                + "-gridRowsxCols: specifies board size\n"
                + "-iN: number of I pieces\n"
                + "-oN: number of O pieces\n"
                + "-tN: number of T pieces\n"
                + "-jN: number of J pieces\n"
                + "-lN: number of L pieces\n"
                + "-sN: number of S pieces\n"
                + "-zN: number of Z pieces\n"
                + "\n"
                + "Example: TetrisPuzzleSolver.jar -nogui -parallel -grid6x8 -i1 -o5 -t2 -j0 -l1 -s2 -z1"
        );
        System.exit(-1);
    }

    private static void printBoard(int[][] board) {
        for (int y = 0; y < board.length; y++) {
            for (int x = 0; x < board[0].length; x++) {
                System.out.print(board[y][x] + "\t");
            }
            System.out.print("\n");
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        Integer uiMode = null; //0=cli, 1=gui
        Integer algorithm = null; //0=classic, 1=parallel
        Integer h = null, w = null; //grid size
        Integer i = null, o = null, t = null, j = null, l = null, s = null, z = null; //pieces
        boolean firstArg = true;
        if (args.length != 0) {
            for (String arg : args) {
                if (firstArg && arg.startsWith("-LOAD")) {
                    GZIPInputStream in = null;
                    try {
                        in = new GZIPInputStream(new FileInputStream(arg.substring(5)));
                        TetrisPuzzleSolverMT solver = TetrisPuzzleSolverMT.loadState(in);
                        Main gui = new Main();
                        gui.rows.setValue(solver.getHeight());
                        gui.cols.setValue(solver.getWidth());
                        gui.i.setValue(solver.getIBlocks());
                        gui.o.setValue(solver.getOBlocks());
                        gui.t.setValue(solver.getTBlocks());
                        gui.j.setValue(solver.getJBlocks());
                        gui.l.setValue(solver.getLBlocks());
                        gui.s.setValue(solver.getSBlocks());
                        gui.z.setValue(solver.getZBlocks());
                        new Visualizer(solver, gui).setVisible(true);
                        return;
                    } catch (Throwable ex) {
                        System.out.println("Can't load state: " + ex);
                        System.exit(2);
                    } finally {
                        try {
                            in.close();
                        } catch (IOException ex) {
                        }
                    }
                } else if (arg.equals("-nogui")) {
                    if (uiMode != null) {
                        printHelp();
                    }
                    uiMode = 0;

                } else if (arg.equals("-gui")) {
                    if (uiMode != null) {
                        printHelp();
                    }
                    uiMode = 1;
                } else if (arg.equals("-classic")) {
                    if (algorithm != null) {
                        printHelp();
                    }
                    algorithm = 0;
                } else if (arg.equals("-parallel")) {
                    if (algorithm != null) {
                        printHelp();
                    }
                    algorithm = 1;
                } else if (arg.startsWith("-grid")) {
                    if (w != null || h != null) {
                        printHelp();
                    }
                    String grid = arg.substring(5);
                    String[] hw = grid.split("x");
                    if (hw.length == 2) {
                        try {
                            h = Integer.parseInt(hw[0]);
                            w = Integer.parseInt(hw[1]);
                            if (h < 1 || w < 1) {
                                printHelp();
                            }
                        } catch (Exception e) {
                            printHelp();
                        }
                    }
                } else if (arg.startsWith("-i")) {
                    if (i != null) {
                        printHelp();
                    }
                    String n = arg.substring(2);
                    try {
                        i = Integer.parseInt(n);
                        if (i < 0) {
                            printHelp();
                        }
                    } catch (Exception e) {
                        printHelp();
                    }
                } else if (arg.startsWith("-o")) {
                    if (o != null) {
                        printHelp();
                    }
                    String n = arg.substring(2);
                    try {
                        o = Integer.parseInt(n);
                        if (o < 0) {
                            printHelp();
                        }
                    } catch (Exception e) {
                        printHelp();
                    }
                } else if (arg.startsWith("-t")) {
                    if (t != null) {
                        printHelp();
                    }
                    String n = arg.substring(2);
                    try {
                        t = Integer.parseInt(n);
                        if (t < 0) {
                            printHelp();
                        }
                    } catch (Exception e) {
                        printHelp();
                    }
                } else if (arg.startsWith("-j")) {
                    if (j != null) {
                        printHelp();
                    }
                    String n = arg.substring(2);
                    try {
                        j = Integer.parseInt(n);
                        if (j < 0) {
                            printHelp();
                        }
                    } catch (Exception e) {
                        printHelp();
                    }
                } else if (arg.startsWith("-l")) {
                    if (l != null) {
                        printHelp();
                    }
                    String n = arg.substring(2);
                    try {
                        l = Integer.parseInt(n);
                        if (l < 0) {
                            printHelp();
                        }
                    } catch (Exception e) {
                        printHelp();
                    }
                } else if (arg.startsWith("-s")) {
                    if (s != null) {
                        printHelp();
                    }
                    String n = arg.substring(2);
                    try {
                        s = Integer.parseInt(n);
                        if (s < 0) {
                            printHelp();
                        }
                    } catch (Exception e) {
                        printHelp();
                    }
                } else if (arg.startsWith("-z")) {
                    if (z != null) {
                        printHelp();
                    }
                    String n = arg.substring(2);
                    try {
                        z = Integer.parseInt(n);
                        if (z < 0) {
                            printHelp();
                        }
                    } catch (Exception e) {
                        printHelp();
                    }
                } else {
                    //invalid parameter
                    printHelp();
                }
                firstArg = false;
            }
            if (uiMode == null) {
                uiMode = 1; //gui by default
            }
            if (algorithm == null) {
                algorithm = 1; //parallel by default
            }
            if (w == null || h == null || i == null || o == null || t == null || j == null || l == null || s == null || z == null) { //missing a required parameter
                printHelp();
            }
            if (uiMode == 0) { //cli
                long lastT = System.nanoTime(), lastIterations = 0;
                System.out.println("Solving...");
                if (algorithm == 0) { //classic algorithm
                    final TetrisPuzzleSolver solver = new TetrisPuzzleSolver(w, h, i, o, t, j, l, s, z);
                    new Thread() {
                        public void run() {
                            setPriority(Thread.MAX_PRIORITY);
                            long startT = System.nanoTime();
                            if (solver.solve()) {
                                System.out.println("Solved in " + ((System.nanoTime() - startT) / 1000000L) + " ms");
                                printBoard(solver.getBoard());
                                System.exit(0);
                            } else {
                                System.out.println("Impossible");
                                System.exit(1);
                            }
                        }
                    }.start();
                    for (;;) {
                        try {
                            Thread.sleep(100);
                        } catch (InterruptedException ex) {
                        }
                        long time = System.nanoTime();
                        long iters = solver.getIterations();
                        System.out.println((iters - lastIterations) * (1000000000L / (time - lastT)) + " iterations/s");
                        lastIterations = iters;
                        lastT = t;
                    }
                }
                if (algorithm == 1) { //parallel algorithm
                    final TetrisPuzzleSolverMT solver = new TetrisPuzzleSolverMT(w, h, i, o, t, j, l, s, z);
                    new Thread() {
                        public void run() {
                            setPriority(Thread.MAX_PRIORITY);
                            long startT = System.nanoTime();
                            Solution sol = solver.solve();
                            if (sol != null) {
                                System.out.println("Solved in " + ((System.nanoTime() - startT) / 1000000L) + " ms");
                                printBoard(sol.get());
                                System.exit(0);
                            } else {
                                System.out.println("Impossible");
                                System.exit(1);
                            }
                        }
                    }.start();

                    for (;;) {
                        try {
                            Thread.sleep(100);
                        } catch (InterruptedException ex) {
                        }
                        long time = System.nanoTime();
                        long iters = solver.getIterations();
                        System.out.println((iters - lastIterations) * (1000000000L / (time - lastT)) + " iterations/s");
                        lastIterations = iters;
                        lastT = t;
                    }
                }
            }
            if (uiMode == 1) { //gui
                if (algorithm == 0) { //classic algorithm
                    new Visualizer(new TetrisPuzzleSolver(w, h, i, o, t, j, l, s, z), null).setVisible(true);
                }
                if (algorithm == 1) { //parallel algorithm
                    new Visualizer(new TetrisPuzzleSolverMT(w, h, i, o, t, j, l, s, z), null).setVisible(true);
                }
            }
        } else {
            //no parameters, show full gui
            new Main().setVisible(true);

        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JSpinner cols;
    private javax.swing.JSpinner i;
    private javax.swing.JSpinner j;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JSpinner l;
    private javax.swing.JSpinner o;
    private javax.swing.JComboBox optimization;
    private javax.swing.JSpinner rows;
    private javax.swing.JSpinner s;
    private javax.swing.JButton solve;
    private javax.swing.JSpinner t;
    private javax.swing.JSpinner z;
    // End of variables declaration//GEN-END:variables
}
